<!DOCTYPE html>
<html lang="en">

<head>
    <title>Sensor FOV Visualizer - Tangram Vision</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <!--
    <div id="watermark"></div>
    -->

    <div id="corner-watermark"><a href="https://tangramvision.com" target="_blank" rel="noopener"><img
                alt="Tangram Vision" src="assets/tangram-logo.png"></a></div>


    <script type="module">

        import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports,min/optimized/three.js';
        window.THREE = THREE;
        import { CameraHelperArc } from './CameraHelperArc.js';

        import { GUI } from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports,min/unoptimized/examples/jsm/libs/dat.gui.module.js';

        import { OrbitControls } from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports,min/unoptimized/examples/jsm/controls/OrbitControls.js';

        let renderer, scene, camera;
        let activeCamera;

        let spotLight, lightHelper, shadowCameraHelper;
        let cam, camHelper;

        let _preventExtraRenders = false;

        let props = [];

        let gui;
        let farController, nearController, sensorController, fovController, aspectController;

        function init() {

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.shadowMap.enabled = true;

            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-4, 3, -3);
            const lookAtTarget = new THREE.Vector3(2, 2, 0);

            cam = new THREE.PerspectiveCamera(30, 16.0 / 9.0, 1, 1000);
            window.cam = cam;
            cam.position.set(0, 2, 0);
            cam.rotateY(-Math.PI / 2);
            cam.near = 0.5;
            cam.far = 10;
            scene.add(cam);

            const size = 10;
            const divisions = 10;
            for (let row = 0; row < 3; row++) {
                for (let col = -1; col < 2; col++) {
                    const gridHelper = new THREE.GridHelper(size, divisions, new THREE.Color(0xffffff), new THREE.Color(0x444444));
                    gridHelper.position.set(row * size, 0, col * size);
                    scene.add(gridHelper);
                }
            }

            // const polarGridHelper = new THREE.PolarGridHelper(200, 16, 8, 64, 0x0000ff, 0x808080);
            // polarGridHelper.position.y = - 150;
            // polarGridHelper.position.x = 200;
            // scene.add(polarGridHelper);

            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.position.set(0, 0.01, 0);
            scene.add(axesHelper);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render);
            // controls.minDistance = 20;
            controls.maxDistance = 100;
            controls.enablePan = true;
            controls.target = lookAtTarget;
            // Need to set camera lookat after OrbitControls, otherwise it looks at the origin
            camera.lookAt(lookAtTarget);
            activeCamera = camera;

            const ambient = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambient);

            camHelper = new CameraHelperArc(cam);
            scene.add(camHelper);


            // const group = new THREE.Group();
            // const geometry = new THREE.PlaneGeometry(20, 10, 20, 10);

            // const meshMaterial = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, side: THREE.DoubleSide, flatShading: true });
            // const plane = new THREE.Mesh(geometry, meshMaterial);
            // group.add(plane);

            // const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
            // lineMaterial.depthTest = false;
            // // This approach doesn't render all the line segments for some
            // // reason, so switched to using WireframeGeometry.
            // // const planeLines = new THREE.LineSegments(geometry, lineMaterial);
            // const wireframe = new THREE.WireframeGeometry(geometry);
            // const planeLines = new THREE.LineSegments(wireframe, lineMaterial);
            // group.add(planeLines);

            // group.rotateX(-Math.PI / 2);
            // group.position.set(5, 0, 0);
            // scene.add(group);

            // Objects in scene
            const crate = new THREE.BoxGeometry(2, 2, 2);
            const texture = new THREE.TextureLoader().load('assets/crate.gif',
                function (texture) {
                    const material2 = new THREE.MeshBasicMaterial({ map: texture });
                    const mesh = new THREE.Mesh(crate, material2);
                    mesh.position.set(8, 1, 2);
                    props.push(mesh);
                    scene.add(mesh);
                    render();
                });

            render();

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            requestAnimationFrame(render);
        }

        function render() {
            // console.log(performance.now());

            cam.updateProjectionMatrix();
            camHelper.update();

            renderer.render(scene, activeCamera);

        }

        function dtr(d) {
            return d * Math.PI / 180;
        }
        function rtd(r) {
            return r * 180 / Math.PI;
        }
        function maxNear(far) {
            return Math.min(far / 2, 5);
        }
        function aspectFromFov(horizFov, vertFov) {
            return Math.tan(dtr(horizFov / 2)) / Math.tan(dtr(vertFov / 2));
        }

        const sensors = {
            "Intel RealSense D415": { "horizFov": 65, "vertFov": 40, "minRange": 0.3, "maxRange": 10 },
            "Intel RealSense D435/D435i": { "horizFov": 87, "vertFov": 58, "minRange": 0.2, "maxRange": 10 },
            "Intel RealSense D455": { "horizFov": 87, "vertFov": 58, "minRange": 0.6, "maxRange": 10 },
            "Structure Core Mono": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Structure Core RGB": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Mynt Eye S S210": { "horizFov": 95, "vertFov": 50, "minRange": 0.5, "maxRange": 7 },
            "Mynt Eye S S1030": { "horizFov": 122, "vertFov": 76, "minRange": 0.5, "maxRange": 18 },
            "Mynt Eye D D1000-120": { "horizFov": 105, "vertFov": 58, "minRange": 0.3, "maxRange": 10 },
            "Mynt Eye D D1000-50": { "horizFov": 64, "vertFov": 38, "minRange": 0.5, "maxRange": 15 },
            "Mynt Eye D 1200": { "horizFov": 59, "vertFov": 35, "minRange": 0.2, "maxRange": 3 },
            "Mynt Eye P": { "horizFov": 75, "vertFov": 40, "minRange": 0.2, "maxRange": 4.2 },
            "Orbbec Astra +": { "horizFov": 55, "vertFov": 45, "minRange": 0.6, "maxRange": 8 },
            "Orbbec Astra + S": { "horizFov": 55, "vertFov": 45, "minRange": 0.4, "maxRange": 2 },
            "Orbbec Astra Stereo S U3": { "horizFov": 68, "vertFov": 45, "minRange": 0.25, "maxRange": 2.5 },
            "Orbbec Astra Embedded S": { "horizFov": 68, "vertFov": 45, "minRange": 0.25, "maxRange": 1.5 },
            "Orbbec Astra": { "horizFov": 60, "vertFov": 50, "minRange": 0.6, "maxRange": 8 },
            "Orbbec Astra S": { "horizFov": 60, "vertFov": 50, "minRange": 0.4, "maxRange": 2 },
            "Orbbec Astra Pro": { "horizFov": 60, "vertFov": 50, "minRange": 0.6, "maxRange": 8 },
            "Orbbec Astra Mini": { "horizFov": 60, "vertFov": 50, "minRange": 0.6, "maxRange": 5 },
            "Orbbec Astra Mini S": { "horizFov": 60, "vertFov": 50, "minRange": 0.35, "maxRange": 1 },
            "Orbbec Astra Persee": { "horizFov": 60, "vertFov": 49, "minRange": 0.6, "maxRange": 8 },
            "StereoLabs Zed": { "horizFov": 90, "vertFov": 60, "minRange": 0.3, "maxRange": 25 },
            "StereoLabs Zed 2": { "horizFov": 110, "vertFov": 70, "minRange": 0.2, "maxRange": 20 },
            "StereoLabs Zed Mini": { "horizFov": 90, "vertFov": 60, "minRange": 0.1, "maxRange": 15 },
            "pmd Pico Flexx": { "horizFov": 62, "vertFov": 45, "minRange": 0.1, "maxRange": 4 },
            "pmd Pico Monstar": { "horizFov": 100, "vertFov": 85, "minRange": 0.5, "maxRange": 6 },
            "Azure Kinect (Narrow FOV Mode)": { "horizFov": 75, "vertFov": 65, "minRange": 0.5, "maxRange": 5.5 },
            "Azure Kinect (Wide FOV Mode)": { "horizFov": 120, "vertFov": 120, "minRange": 0.25, "maxRange": 2.9 },
        }

        function buildGui() {

            gui = new GUI();

            const params = {
                "min range": cam.near,
                "max range": cam.far,
                "vertical fov": cam.fov,
                "aspect ratio": cam.aspect,
                sensor: "rs1",
                "view from camera": false,
                "show props": true,
            };

            sensorController = gui.add(params, 'sensor', Object.keys(sensors)).onChange(function (val) {

                console.log(`sensor=${val}`);
                const params = sensors[val];

                _preventExtraRenders = true;
                nearController.setValue(params["minRange"]);
                farController.setValue(params["maxRange"]);
                fovController.setValue(params["vertFov"]);
                const aspect = aspectFromFov(params["horizFov"], params["vertFov"]);
                aspectController.setValue(aspect);
                requestAnimationFrame(render);
                _preventExtraRenders = false;

            });

            const folder = gui.addFolder("Advanced");

            nearController = folder.add(params, 'min range', 0.1, maxNear(cam.far)).onChange(function (val) {

                cam.near = val;
                farController.min(val + 1);
                farController.updateDisplay();
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            farController = folder.add(params, 'max range', cam.near + 1, 40).onChange(function (val) {

                cam.far = val;
                nearController.max(maxNear(val));
                nearController.updateDisplay();
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            fovController = folder.add(params, 'vertical fov', 10, 179).onChange(function (val) {

                cam.fov = val;
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            aspectController = folder.add(params, 'aspect ratio', 0.4, 5.0).onChange(function (val) {

                cam.aspect = val;
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            folder.add(params, 'view from camera').onChange(function (val) {

                if (val) {
                    activeCamera = cam;
                }
                else {
                    activeCamera = camera;
                }
                requestAnimationFrame(render);

            });

            folder.add(params, 'show props').onChange(function (val) {

                props.forEach(function (p) {
                    p.visible = val;
                })
                requestAnimationFrame(render);

            });

            gui.open();

        }

        init();

        buildGui();

        sensorController.setValue("Intel RealSense D415");
        // Setting sensor triggers a render already.
        // render();

    </script>

</body>

</html>