<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - lights - spotlight</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <div id="info">
        FOV Explorer by <a href="https://tangramvision.com" target="_blank" rel="noopener">Tangram Vision</a>
    </div>

    <script type="module">
        // from https://threejs.org/examples/#webgl_lights_spotlight
        // inspiration https://cs.wellesley.edu/~cs307/threejs/demos/Camera/frustum.shtml
        // inspiration https://www.smeenk.com/webgl/kinectfovexplorer.html

        import * as THREE from 'https://cdn.skypack.dev/three';
        import { CameraHelperArc } from './CameraHelperArc.js';

        import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/dat.gui.module.js';

        import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';

        let renderer, scene, camera;
        let activeCamera;

        let spotLight, lightHelper, shadowCameraHelper;
        let cam, camHelper;

        let gui;
        let farController, nearController, sensorController, fovController, aspectController;

        function init() {

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.shadowMap.enabled = true;

            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-4, 3, -3);
            const lookAtTarget = new THREE.Vector3(2, 2, 0);

            cam = new THREE.PerspectiveCamera(30, 16.0 / 9.0, 1, 1000);
            cam.position.set(0, 2, 0);
            cam.rotateY(-Math.PI / 2);
            cam.near = 0.5;
            cam.far = 10;
            scene.add(cam);
            camHelper = new CameraHelperArc(cam);
            scene.add(camHelper);

            /*
            const size = 10;
            const divisions = 10;
            for (let i = 0; i < 2; i++) {
                const gridHelper = new THREE.GridHelper(size, divisions, new THREE.Color(0xffffff), new THREE.Color(0x444444));
                gridHelper.position.set(i * size, 0, 0);
                scene.add(gridHelper);
            }
            */

            const polarGridHelper = new THREE.PolarGridHelper(200, 16, 8, 64, 0x0000ff, 0x808080);
            polarGridHelper.position.y = - 150;
            polarGridHelper.position.x = 200;
            // scene.add(polarGridHelper);

            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.position.set(0, 0.01, 0);
            scene.add(axesHelper);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render);
            // controls.minDistance = 20;
            controls.maxDistance = 100;
            controls.enablePan = true;
            controls.target = lookAtTarget;
            // Need to set camera lookat after OrbitControls, otherwise it looks at the origin
            camera.lookAt(lookAtTarget);
            activeCamera = camera;

            const ambient = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambient);


            const group = new THREE.Group();
            const geometry = new THREE.PlaneGeometry(20, 10, 20, 10);

            const meshMaterial = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, side: THREE.DoubleSide, flatShading: true });
            const plane = new THREE.Mesh(geometry, meshMaterial);
            group.add(plane);

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
            lineMaterial.depthTest = false;
            // This approach doesn't render all the line segments for some
            // reason, so switched to using WireframeGeometry.
            // const planeLines = new THREE.LineSegments(geometry, lineMaterial);
            const wireframe = new THREE.WireframeGeometry(geometry);
            const planeLines = new THREE.LineSegments(wireframe, lineMaterial);
            group.add(planeLines);

            group.rotateX(-Math.PI / 2);
            group.position.set(5, 0, 0);
            scene.add(group);

            // Eyeballing the ellipse curve for min and max range
            const vertCurve = new THREE.EllipseCurve(
                0, 0,            // ax, aY
                10, 10,           // xRadius, yRadius
                - dtr(20), dtr(20),  // aStartAngle, aEndAngle
                false,            // aClockwise
                0                 // aRotation
            );
            const points2 = vertCurve.getPoints(50);
            const geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
            const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            // TODO: ellipse is just a bunch of lines... so that could be added
            // to CameraHelperArc's list of points/vertices
            const ellipse = new THREE.Line(geometry2, material);
            ellipse.position.set(cam.position.x, cam.position.y, cam.position.z);
            scene.add(ellipse);

            // Eyeballing the ellipse curve for min and max range
            const horizCurve = new THREE.EllipseCurve(
                0, 0,            // ax, aY
                10, 10,           // xRadius, yRadius
                - dtr(32.5), dtr(32.5),  // aStartAngle, aEndAngle
                false,            // aClockwise
                0                 // aRotation
            );
            const points3 = horizCurve.getPoints(50);
            const geometry3 = new THREE.BufferGeometry().setFromPoints(points3);
            // TODO: ellipse is just a bunch of lines... so that could be added
            // to CameraHelperArc's list of points/vertices
            const ellipse2 = new THREE.Line(geometry3, material);
            ellipse2.rotateX(Math.PI / 2);
            ellipse2.position.set(cam.position.x, cam.position.y, cam.position.z);
            scene.add(ellipse2);


            // Objects in scene
            const geometry4 = new THREE.BoxGeometry(2, 2, 2);
            const texture = new THREE.TextureLoader().load('textures/crate.gif',
                function (texture) {
                    const material2 = new THREE.MeshBasicMaterial({ map: texture });
                    const mesh = new THREE.Mesh(geometry4, material2);
                    mesh.position.set(8, 1, 2);
                    scene.add(mesh);
                    render();
                });



            //

            // spotLight = new THREE.SpotLight(0xffffff, 1);
            // spotLight.position.set(15, 40, 35);
            // spotLight.angle = Math.PI / 4;
            // spotLight.penumbra = 0.1;
            // spotLight.decay = 2;
            // spotLight.distance = 200;

            // spotLight.castShadow = true;
            // spotLight.shadow.mapSize.width = 512;
            // spotLight.shadow.mapSize.height = 512;
            // spotLight.shadow.camera.near = 10;
            // spotLight.shadow.camera.far = 200;
            // spotLight.shadow.focus = 1;
            // scene.add(spotLight);

            // lightHelper = new THREE.SpotLightHelper(spotLight);
            // scene.add(lightHelper);

            // shadowCameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
            // scene.add(shadowCameraHelper);

            //

            // let material = new THREE.MeshPhongMaterial({ color: 0x808080, dithering: true });

            // let geometry = new THREE.PlaneGeometry(2000, 2000);

            // let mesh = new THREE.Mesh(geometry, material);
            // mesh.position.set(0, - 1, 0);
            // mesh.rotation.x = - Math.PI * 0.5;
            // mesh.receiveShadow = true;
            // scene.add(mesh);

            //

            // let material = new THREE.MeshPhongMaterial({ color: 0x4080ff, dithering: true });

            // let geometry = new THREE.CylinderGeometry(5, 5, 2, 32, 1, false);

            // let mesh = new THREE.Mesh(geometry, material);
            // mesh.position.set(0, 5, 0);
            // mesh.castShadow = true;
            // scene.add(mesh);

            render();

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function render() {

            // lightHelper.update();

            // TODO: is this needed?
            cam.updateProjectionMatrix();
            camHelper.update();

            // shadowCameraHelper.update();

            renderer.render(scene, activeCamera);
            // renderer.render(scene, cam);

        }

        function dtr(d) {
            return d * Math.PI / 180;
        }
        function rtd(r) {
            return r * 180 / Math.PI;
        }
        function aspectFromFov(horizFov, vertFov) {
            return Math.tan(dtr(horizFov / 2)) / Math.tan(dtr(vertFov / 2));
        }

        const sensors = {
            "Intel RealSense D415": { "horizFov": 65, "vertFov": 40, "minRange": 0.3, "maxRange": 10 },
            "Intel RealSense D435/D435i": { "horizFov": 87, "vertFov": 58, "minRange": 0.2, "maxRange": 10 },
            "Intel RealSense 455": { "horizFov": 87, "vertFov": 58, "minRange": 0.6, "maxRange": 10 },
            "Structure Core Mono": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Structure Core RGB": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Mynt Eye S S210": { "horizFov": 95, "vertFov": 50, "minRange": 0.5, "maxRange": 7 },
            "Mynt Eye S S1030": { "horizFov": 122, "vertFov": 76, "minRange": 0.5, "maxRange": 18 },
        }

        function buildGui() {

            gui = new GUI();

            const params = {
                near: cam.near,
                far: cam.far,
                fov: cam.fov,
                aspect: cam.aspect,
                sensor: "rs1",
                viewFromCamera: false,
            };

            sensorController = gui.add(params, 'sensor', Object.keys(sensors)).onChange(function (val) {

                console.log(`sensor=${val}`);
                const params = sensors[val];
                nearController.setValue(params["minRange"]);
                farController.setValue(params["maxRange"]);
                fovController.setValue(params["vertFov"]);
                const aspect = aspectFromFov(params["horizFov"], params["vertFov"]);
                aspectController.setValue(aspect);
                render();

            });

            nearController = gui.add(params, 'near', 0.1, cam.far - 1).onChange(function (val) {

                cam.near = val;
                farController.min(val + 1);
                farController.updateDisplay();
                render();

            });

            farController = gui.add(params, 'far', cam.near + 1, 200).onChange(function (val) {

                cam.far = val;
                nearController.max(val - 1);
                nearController.updateDisplay();
                render();

            });

            fovController = gui.add(params, 'fov', 10, 180).onChange(function (val) {

                cam.fov = val;
                render();

            });

            aspectController = gui.add(params, 'aspect', 0.1, 10.0).onChange(function (val) {

                cam.aspect = val;
                render();

            });

            gui.add(params, 'viewFromCamera').onChange(function (val) {

                if (val) {
                    activeCamera = cam;
                }
                else {
                    activeCamera = camera;
                }
                render();

            });

            gui.open();

        }

        init();

        buildGui();

        render();

        sensorController.setValue("Intel RealSense D415");

    </script>

</body>

</html>