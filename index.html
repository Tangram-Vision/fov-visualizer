<!DOCTYPE html>
<html lang="en">

<head>
    <title>Sensor FOV Visualizer - Tangram Vision</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <!--
    <div id="watermark"></div>
    -->

    <div id="corner-watermark"><a href="https://tangramvision.com" target="_blank" rel="noopener"><img
                alt="Tangram Vision" src="assets/tangram-logo.png"></a></div>


    <script type="module">

        import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports,min/optimized/three.js';
        window.THREE = THREE;
        import { CameraHelperArc } from './CameraHelperArc.js';
        import { CSS2DObject, CSS2DRenderer } from './CSS2DRenderer.js';

        import { GUI } from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports,min/unoptimized/examples/jsm/libs/dat.gui.module.js';

        import { OrbitControls } from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports,min/unoptimized/examples/jsm/controls/OrbitControls.js';

        let renderer, scene, camera, labelRenderer;
        let activeCamera;

        let spotLight, lightHelper, shadowCameraHelper;
        let sensor, camHelper;
        let checkerboardTexture, gridHelper, checkerboard;

        let minRangeLabel, maxRangeLabel;

        let _preventExtraRenders = false;

        let props = [];

        let gui;
        let farController, nearController, sensorController, fovController, aspectController, propDistanceController, checkerboardDistanceController, gridSizeController;

        function init() {

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.shadowMap.enabled = true;

            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            document.body.appendChild(labelRenderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-4, 3, -3);
            const lookAtTarget = new THREE.Vector3(2, 2, 0);

            sensor = new THREE.PerspectiveCamera(30, 16.0 / 9.0, 1, 1000);
            window.sensor = sensor;
            sensor.position.set(0, 2, 0);
            sensor.rotateY(-Math.PI / 2);
            sensor.near = 0.5;
            sensor.far = 10;
            scene.add(sensor);

            /*
            const size = 10;
            const divisions = 10;
            for (let row = 0; row < 3; row++) {
                for (let col = -1; col < 2; col++) {
                    const gridHelper = new THREE.GridHelper(size, divisions, new THREE.Color(0xffffff), new THREE.Color(0x444444));
                    gridHelper.position.set(row * size, 0, col * size);
                    scene.add(gridHelper);
                }
            }
            */
            gridHelper = new THREE.GridHelper(40, 40, new THREE.Color(0xffffff), new THREE.Color(0x444444));
            gridHelper.position.set(10, 0, 0);
            scene.add(gridHelper);

            // const polarGridHelper = new THREE.PolarGridHelper(200, 16, 8, 64, 0x0000ff, 0x808080);
            // polarGridHelper.position.y = - 150;
            // polarGridHelper.position.x = 200;
            // scene.add(polarGridHelper);

            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.position.set(0, 0.01, 0);
            scene.add(axesHelper);

            const controls = new OrbitControls(camera, labelRenderer.domElement);
            controls.addEventListener('change', render);
            // controls.minDistance = 20;
            controls.maxDistance = 100;
            controls.enablePan = true;
            controls.target = lookAtTarget;
            // Need to set camera lookat after OrbitControls, otherwise it looks at the origin
            camera.lookAt(lookAtTarget);
            activeCamera = camera;

            const ambient = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambient);

            camHelper = new CameraHelperArc(sensor);
            scene.add(camHelper);


            const geometry = new THREE.PlaneGeometry(40, 40, 1, 1);
            const textureLoader = new THREE.TextureLoader();
            checkerboardTexture = textureLoader.load("assets/checkerboard.png", function (texture) {
                checkerboardTexture.wrapS = checkerboardTexture.wrapT = THREE.RepeatWrapping;
                checkerboardTexture.repeat.set(20, 20);
                checkerboardTexture.magFilter = THREE.NearestFilter;
                const meshMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, map: checkerboardTexture });
                checkerboard = new THREE.Mesh(geometry, meshMaterial);
                checkerboard.rotateY(-Math.PI / 2);
                checkerboard.position.set(10, 0, 0);
                scene.add(checkerboard);
                render();
            });


            // const group = new THREE.Group();
            // const geometry = new THREE.PlaneGeometry(20, 10, 20, 10);

            // const meshMaterial = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, side: THREE.DoubleSide, flatShading: true });
            // const plane = new THREE.Mesh(geometry, meshMaterial);
            // group.add(plane);

            // const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
            // lineMaterial.depthTest = false;
            // // This approach doesn't render all the line segments for some
            // // reason, so switched to using WireframeGeometry.
            // // const planeLines = new THREE.LineSegments(geometry, lineMaterial);
            // const wireframe = new THREE.WireframeGeometry(geometry);
            // const planeLines = new THREE.LineSegments(wireframe, lineMaterial);
            // group.add(planeLines);

            // group.rotateX(-Math.PI / 2);
            // group.position.set(5, 0, 0);
            // scene.add(group);

            // Objects in scene
            const crate = new THREE.BoxGeometry(2, 2, 2);
            const texture = new THREE.TextureLoader().load('assets/crate.gif', function (texture) {
                const material2 = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(crate, material2);
                mesh.position.set(8, 1, 2);
                props.push(mesh);
                scene.add(mesh);
                render();
            });

            const minRangeLabelDiv = document.createElement('div');
            minRangeLabelDiv.className = 'label';
            minRangeLabelDiv.textContent = 'Min Range: 0.0 m';
            // minRangeLabelDiv.style.marginTop = '-1em';
            minRangeLabel = new CSS2DObject(minRangeLabelDiv);
            minRangeLabel.position.set(1, 1, 1);
            scene.add(minRangeLabel);

            const maxRangeLabelDiv = document.createElement('div');
            maxRangeLabelDiv.className = 'label';
            maxRangeLabelDiv.textContent = 'Max Range: 0.0 m';
            // maxRangeLabelDiv.style.marginTop = '-1em';
            maxRangeLabel = new CSS2DObject(maxRangeLabelDiv);
            maxRangeLabel.position.set(2, 2, 2);
            scene.add(maxRangeLabel);

            render();

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            requestAnimationFrame(render);
        }

        function render() {
            // console.log(performance.now());

            sensor.updateProjectionMatrix();
            camHelper.update();
            updateRangeTextLabels();

            renderer.render(scene, activeCamera);
            labelRenderer.render(scene, activeCamera);

        }

        function updateRangeTextLabels() {
            const near = camHelper.pointMap['c'][0];
            const coords = camHelper.geometry.getAttribute('position');
            // console.log(`Min: ${-coords.getZ(near)}, ${coords.getY(near)}, ${coords.getX(near)}`);

            // Small adjustment to X coordinate so it will definitely be inside
            // the camera frustum and render when viewing through the camera.
            minRangeLabel.position.set(-coords.getZ(near) + 0.01, coords.getY(near) + 2, coords.getX(near));
            minRangeLabel.element.textContent = `Min Range: ${sensor.near.toFixed(1)} m.`;
            const far = camHelper.pointMap['t'][0];

            // Small adjustment to X coordinate so it will definitely be inside
            // the camera frustum and render when viewing through the camera.
            maxRangeLabel.position.set(-coords.getZ(far) - 0.01, coords.getY(far) + 2, coords.getX(far));
            maxRangeLabel.element.textContent = `Max Range: ${sensor.far.toFixed(1)} m.`;
        }

        function dtr(d) {
            return d * Math.PI / 180;
        }
        function rtd(r) {
            return r * 180 / Math.PI;
        }
        function maxNear(far) {
            return Math.min(far / 2, 5);
        }
        function aspectFromFov(horizFov, vertFov) {
            return Math.tan(dtr(horizFov / 2)) / Math.tan(dtr(vertFov / 2));
        }

        const sensors = {
            "Intel RealSense D415": { "horizFov": 65, "vertFov": 40, "minRange": 0.3, "maxRange": 10 },
            "Intel RealSense D435/D435i": { "horizFov": 87, "vertFov": 58, "minRange": 0.2, "maxRange": 10 },
            "Intel RealSense D455": { "horizFov": 87, "vertFov": 58, "minRange": 0.6, "maxRange": 10 },
            "Structure Core Mono": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Structure Core RGB": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Mynt Eye S S210": { "horizFov": 95, "vertFov": 50, "minRange": 0.5, "maxRange": 7 },
            "Mynt Eye S S1030": { "horizFov": 122, "vertFov": 76, "minRange": 0.5, "maxRange": 18 },
            "Mynt Eye D D1000-120": { "horizFov": 105, "vertFov": 58, "minRange": 0.3, "maxRange": 10 },
            "Mynt Eye D D1000-50": { "horizFov": 64, "vertFov": 38, "minRange": 0.5, "maxRange": 15 },
            "Mynt Eye D 1200": { "horizFov": 59, "vertFov": 35, "minRange": 0.2, "maxRange": 3 },
            "Mynt Eye P": { "horizFov": 75, "vertFov": 40, "minRange": 0.2, "maxRange": 4.2 },
            "Orbbec Astra +": { "horizFov": 55, "vertFov": 45, "minRange": 0.6, "maxRange": 8 },
            "Orbbec Astra + S": { "horizFov": 55, "vertFov": 45, "minRange": 0.4, "maxRange": 2 },
            "Orbbec Astra Stereo S U3": { "horizFov": 68, "vertFov": 45, "minRange": 0.25, "maxRange": 2.5 },
            "Orbbec Astra Embedded S": { "horizFov": 68, "vertFov": 45, "minRange": 0.25, "maxRange": 1.5 },
            "Orbbec Astra": { "horizFov": 60, "vertFov": 50, "minRange": 0.6, "maxRange": 8 },
            "Orbbec Astra S": { "horizFov": 60, "vertFov": 50, "minRange": 0.4, "maxRange": 2 },
            "Orbbec Astra Pro": { "horizFov": 60, "vertFov": 50, "minRange": 0.6, "maxRange": 8 },
            "Orbbec Astra Mini": { "horizFov": 60, "vertFov": 50, "minRange": 0.6, "maxRange": 5 },
            "Orbbec Astra Mini S": { "horizFov": 60, "vertFov": 50, "minRange": 0.35, "maxRange": 1 },
            "Orbbec Astra Persee": { "horizFov": 60, "vertFov": 49, "minRange": 0.6, "maxRange": 8 },
            "StereoLabs Zed": { "horizFov": 90, "vertFov": 60, "minRange": 0.3, "maxRange": 25 },
            "StereoLabs Zed 2": { "horizFov": 110, "vertFov": 70, "minRange": 0.2, "maxRange": 20 },
            "StereoLabs Zed Mini": { "horizFov": 90, "vertFov": 60, "minRange": 0.1, "maxRange": 15 },
            "pmd Pico Flexx": { "horizFov": 62, "vertFov": 45, "minRange": 0.1, "maxRange": 4 },
            "pmd Pico Monstar": { "horizFov": 100, "vertFov": 85, "minRange": 0.5, "maxRange": 6 },
            "Azure Kinect (Narrow FOV Mode)": { "horizFov": 75, "vertFov": 65, "minRange": 0.5, "maxRange": 5.5 },
            "Azure Kinect (Wide FOV Mode)": { "horizFov": 120, "vertFov": 120, "minRange": 0.25, "maxRange": 2.9 },
        }

        function buildGui() {

            gui = new GUI();

            const params = {
                "min range": sensor.near,
                "max range": sensor.far,
                "vertical fov": sensor.fov,
                "aspect ratio": sensor.aspect,
                "sensor": "rs1",
                "view from camera": false,
                "show props": true,
                "prop dist (m.)": 8,
                "board dist (m.)": 10,
                "grid size (m.)": 1,
            };

            sensorController = gui.add(params, 'sensor', Object.keys(sensors)).onChange(function (val) {

                console.log(`sensor=${val}`);
                const params = sensors[val];

                _preventExtraRenders = true;
                nearController.setValue(params["minRange"]);
                farController.setValue(params["maxRange"]);
                fovController.setValue(params["vertFov"]);
                const aspect = aspectFromFov(params["horizFov"], params["vertFov"]);
                aspectController.setValue(aspect);
                requestAnimationFrame(render);
                _preventExtraRenders = false;

            });

            checkerboardDistanceController = gui.add(params, 'board dist (m.)', 0.1, 30.0, 0.1).onChange(function (val) {

                checkerboard.position.set(val, 0, 0);
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            gridSizeController = gui.add(params, 'grid size (m.)', 0.01, 2, 0.01).onChange(function (val) {

                // Texture is 2x2 in pixels.
                // To have a 1m grid size (the plane is 40m square), the texture must be scaled by 40m/1m/2.
                const scalar = 40 / val / 2;
                checkerboardTexture.repeat.set(scalar, scalar);

                // Remove and re-create the gridHelper with the new grid size.
                scene.remove(gridHelper);
                gridHelper = new THREE.GridHelper(40, 40 / val, new THREE.Color(0xffffff), new THREE.Color(0x444444));
                gridHelper.position.set(10, 0, 0);
                scene.add(gridHelper);
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            const folder = gui.addFolder("Advanced");

            nearController = folder.add(params, 'min range', 0.1, maxNear(sensor.far), 0.1).onChange(function (val) {

                sensor.near = val;
                farController.min(val + 1);
                farController.updateDisplay();
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            farController = folder.add(params, 'max range', sensor.near + 1, 40, 0.1).onChange(function (val) {

                sensor.far = val;
                nearController.max(maxNear(val));
                nearController.updateDisplay();
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            fovController = folder.add(params, 'vertical fov', 10, 179).onChange(function (val) {

                sensor.fov = val;
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            aspectController = folder.add(params, 'aspect ratio', 0.4, 5.0).onChange(function (val) {

                sensor.aspect = val;
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            propDistanceController = folder.add(params, 'prop dist (m.)', 0, 30.0, 0.1).onChange(function (val) {

                props.forEach(function (p) {
                    p.position.set(val, 1, 2);
                })
                if (!_preventExtraRenders) requestAnimationFrame(render);

            });

            folder.add(params, 'show props').onChange(function (val) {

                props.forEach(function (p) {
                    p.visible = val;
                })
                requestAnimationFrame(render);

            });

            folder.add(params, 'view from camera').onChange(function (val) {

                if (val) {
                    activeCamera = sensor;
                    minRangeLabel.visible = false;
                    maxRangeLabel.element.style.marginTop = "2em";
                    maxRangeLabel.element.style.marginLeft = "-5.5em";
                }
                else {
                    activeCamera = camera;
                    /* matches style in main.css */
                    minRangeLabel.visible = true;
                    maxRangeLabel.element.style.marginTop = "";
                    maxRangeLabel.element.style.marginLeft = "";
                }
                requestAnimationFrame(render);

            });

            gui.open();

        }

        init();

        buildGui();

        sensorController.setValue("Intel RealSense D415");
        // Setting sensor triggers a render already.
        // render();

    </script>

</body>

</html>