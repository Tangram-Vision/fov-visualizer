<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - lights - spotlight</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - spotlight by <a
            href="http://master-domain.com" target="_blank" rel="noopener">Master James</a><br />
    </div>

    <script type="module">

        import * as THREE from 'https://cdn.skypack.dev/three';

        import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/dat.gui.module.js';

        import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';

        let renderer, scene, camera;

        let spotLight, lightHelper, shadowCameraHelper;
        let cam, camHelper;

        let gui;
        let farController, nearController;

        function init() {

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.shadowMap.enabled = true;

            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-10, 5, -10);
            camera.lookAt(5, 0, 0);

            cam = new THREE.PerspectiveCamera(30, 16.0 / 9.0, 1, 1000);
            cam.position.set(0, 2, 0);
            cam.rotateY(-Math.PI / 2);
            cam.near = 0.1;
            cam.far = 10;
            scene.add(cam);
            camHelper = new THREE.CameraHelper(cam);
            scene.add(camHelper);

            const size = 10;
            const divisions = 10;

            for (let i = 0; i < 2; i++) {
                const gridHelper = new THREE.GridHelper(size, divisions, new THREE.Color(0xffffff), new THREE.Color(0x444444));
                gridHelper.position.set(i * size, 0, 0);
                scene.add(gridHelper);
            }

            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.position.set(0, 0.01, 0);
            scene.add(axesHelper);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render);
            // controls.minDistance = 20;
            controls.maxDistance = 100;
            controls.enablePan = true;

            const ambient = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambient);

            // spotLight = new THREE.SpotLight(0xffffff, 1);
            // spotLight.position.set(15, 40, 35);
            // spotLight.angle = Math.PI / 4;
            // spotLight.penumbra = 0.1;
            // spotLight.decay = 2;
            // spotLight.distance = 200;

            // spotLight.castShadow = true;
            // spotLight.shadow.mapSize.width = 512;
            // spotLight.shadow.mapSize.height = 512;
            // spotLight.shadow.camera.near = 10;
            // spotLight.shadow.camera.far = 200;
            // spotLight.shadow.focus = 1;
            // scene.add(spotLight);

            // lightHelper = new THREE.SpotLightHelper(spotLight);
            // scene.add(lightHelper);

            // shadowCameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
            // scene.add(shadowCameraHelper);

            //

            // let material = new THREE.MeshPhongMaterial({ color: 0x808080, dithering: true });

            // let geometry = new THREE.PlaneGeometry(2000, 2000);

            // let mesh = new THREE.Mesh(geometry, material);
            // mesh.position.set(0, - 1, 0);
            // mesh.rotation.x = - Math.PI * 0.5;
            // mesh.receiveShadow = true;
            // scene.add(mesh);

            //

            // let material = new THREE.MeshPhongMaterial({ color: 0x4080ff, dithering: true });

            // let geometry = new THREE.CylinderGeometry(5, 5, 2, 32, 1, false);

            // let mesh = new THREE.Mesh(geometry, material);
            // mesh.position.set(0, 5, 0);
            // mesh.castShadow = true;
            // scene.add(mesh);

            render();

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function render() {

            // lightHelper.update();

            // TODO: is this needed?
            cam.updateProjectionMatrix();
            camHelper.update();

            // shadowCameraHelper.update();

            renderer.render(scene, camera);
            // renderer.render(scene, cam);

        }

        function dtr(d) {
            return d * Math.PI / 180;
        }
        function rtd(r) {
            return r * 180 / Math.PI;
        }
        function aspectFromFov(horizFov, vertFov) {
            return Math.tan(dtr(horizFov / 2)) / Math.tan(dtr(vertFov / 2));
        }

        const sensors = {
            "Intel RealSense D415": { "horizFov": 65, "vertFov": 40, "minRange": 0.3, "maxRange": 10 },
            "Intel RealSense D435/D435i": { "horizFov": 87, "vertFov": 58, "minRange": 0.2, "maxRange": 10 },
            "Intel RealSense 455": { "horizFov": 87, "vertFov": 58, "minRange": 0.6, "maxRange": 10 },
            "Structure Core Mono": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Structure Core RGB": { "horizFov": 59, "vertFov": 46, "minRange": 0.3, "maxRange": 10 },
            "Mynt Eye S S210": { "horizFov": 95, "vertFov": 50, "minRange": 0.5, "maxRange": 7 },
            "Mynt Eye S S1030": { "horizFov": 122, "vertFov": 76, "minRange": 0.5, "maxRange": 18 },
        }

        function buildGui() {

            gui = new GUI();

            const params = {
                near: cam.near,
                far: cam.far,
                fov: cam.fov,
                aspect: cam.aspect,
                sensor: "rs1",
            };

            gui.add(params, 'sensor', Object.keys(sensors)).onChange(function (val) {

                console.log(`sensor=${val}`);
                const params = sensors[val];
                cam.near = params["minRange"];
                cam.far = params["maxRange"];
                cam.fov = params["horizFov"];
                cam.aspect = aspectFromFov(params["horizFov"], params["vertFov"]);
                render();

            });

            nearController = gui.add(params, 'near', 0.1, cam.far - 1).onChange(function (val) {

                cam.near = val;
                farController.min(val + 1);
                farController.updateDisplay();
                render();

            });

            farController = gui.add(params, 'far', cam.near + 1, 200).onChange(function (val) {

                cam.far = val;
                nearController.max(val - 1);
                nearController.updateDisplay();
                render();

            });

            gui.add(params, 'fov', 10, 180).onChange(function (val) {

                cam.fov = val;
                render();

            });

            gui.add(params, 'aspect', 0.1, 10.0).onChange(function (val) {

                cam.aspect = val;
                render();

            });

            gui.open();

        }

        init();

        buildGui();

        render();

    </script>

</body>

</html>